name: "Safe: Sync Upstream -> main"

on:
  workflow_dispatch:
  schedule:
    - cron: "0 6 * * *"

permissions:
  contents: write
  pull-requests: write
  actions: write

concurrency:
  group: sync-upstream-main
  cancel-in-progress: false

jobs:
  sync-upstream-into-main:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Configure git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Set upstream remote and fetch
        shell: bash
        run: |
          set -e
          if git remote get-url upstream >/dev/null 2>&1; then
            git remote set-url upstream "https://github.com/gitroomhq/postiz-app.git"
          else
            git remote add upstream "https://github.com/gitroomhq/postiz-app.git"
          fi
          git fetch --prune upstream
          git fetch --prune origin

      - name: Clear GitHub App auth header (use PAT)
        shell: bash
        run: |
          set -e
          # Remove Authorization header injected by actions/checkout so our PAT is used
          git config --global --unset-all http.https://github.com/.extraheader || true
          
      - name: Verify SYNC_TOKEN exists and test auth
        shell: bash
        run: |
          if [ -z "${{ secrets.SYNC_TOKEN }}" ]; then
            echo "ERROR: SYNC_TOKEN secret is not set!"
            echo "Please create a PAT with 'repo' and 'workflow' scopes and add it as SYNC_TOKEN secret"
            exit 1
          fi
          echo "SYNC_TOKEN is configured"
          
          # Test authentication
          curl -s -H "Authorization: token ${{ secrets.SYNC_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}" | jq -r '.permissions // "No permissions found"'
          
      - name: Force PAT for all GitHub HTTPS operations
        shell: bash
        run: |
          set -e
          # Clear all existing auth configs
          git config --global --unset-all http.https://github.com/.extraheader || true
          git config --global --unset-all url."https://github.com/".insteadOf || true
          
          # Set up PAT authentication
          git config --global url."https://x-access-token:${{ secrets.SYNC_TOKEN }}@github.com/".insteadOf "https://github.com/"
          git remote set-url origin "https://x-access-token:${{ secrets.SYNC_TOKEN }}@github.com/${{ github.repository }}.git"
          
          # Verify remote URL
          echo "Origin remote URL: $(git remote get-url origin | sed 's/x-access-token:[^@]*/x-access-token:***/')"
      - name: Align local main to origin/main
        shell: bash
        run: |
          set -e
          if git ls-remote --exit-code --heads origin main >/dev/null 2>&1; then
            git checkout -B main origin/main
          else
            git checkout -B main
          fi

      - name: Try fast-forward merge upstream/main -> main
        id: ff_attempt
        shell: bash
        run: |
          set +e
          if git ls-remote --exit-code --heads upstream main >/dev/null 2>&1; then
            git merge --ff-only upstream/main
            status=$?
            if [ "$status" -eq 0 ]; then
              echo "status=ff" >> "$GITHUB_OUTPUT"
            else
              echo "status=diverged" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "status=no-upstream-main" >> "$GITHUB_OUTPUT"
          fi

      - name: Push main when fast-forward succeeded
        if: steps.ff_attempt.outputs.status == 'ff'
        run: git push "https://x-access-token:${{ secrets.SYNC_TOKEN }}@github.com/${{ github.repository }}.git" HEAD:main

      - name: Create sync branch from upstream/main (when diverged)
        if: steps.ff_attempt.outputs.status == 'diverged'
        shell: bash
        run: |
          set -e
          BR="sync/upstream-into-main/${{ github.run_id }}"
          git checkout -B "$BR" upstream/main
          
          # Remove workflow files that cause GitHub restrictions
          if [ -d ".github/workflows" ]; then
            git rm -rf .github/workflows/ || true
            git commit -m "Remove workflow files to avoid GitHub restrictions" || true
          fi
          
          git push -u "https://x-access-token:${{ secrets.SYNC_TOKEN }}@github.com/${{ github.repository }}.git" "$BR:$BR" --force-with-lease

      - name: Open PR and auto-merge if no conflicts
        if: steps.ff_attempt.outputs.status == 'diverged'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SYNC_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const headBranch = `sync/upstream-into-main/${{ github.run_id }}`;
            const base = 'main';
            const title = 'Sync: upstream â†’ main (auto-merge if no conflicts)';
            const body = [
              'This PR brings upstream/main into your main.',
              '',
              '- Auto-created by sync workflow',
              '- Will auto-merge if no conflicts detected',
              '- Workflow files excluded to avoid GitHub restrictions',
            ].join('\\n');
            
            try {
              // Check for existing PRs
              const { data: prs } = await github.rest.pulls.list({
                owner, repo, state: 'open', head: `${owner}:${headBranch}`, base
              });
              
              let pr;
              if (prs.length > 0) {
                pr = prs[0];
                core.info(`Using existing PR #${pr.number}`);
              } else {
                const { data: newPr } = await github.rest.pulls.create({
                  owner, repo, title, head: headBranch, base, body
                });
                pr = newPr;
                core.info(`Created PR #${pr.number}`);
              }
              
              // Wait a moment for GitHub to process the PR
              await new Promise(resolve => setTimeout(resolve, 3000));
              
              // Check if PR is mergeable (no conflicts)
              const { data: prDetails } = await github.rest.pulls.get({
                owner, repo, pull_number: pr.number
              });
              
              if (prDetails.mergeable === true) {
                core.info('No conflicts detected, auto-merging...');
                await github.rest.pulls.merge({
                  owner, repo, pull_number: pr.number,
                  merge_method: 'merge',
                  commit_title: `Sync upstream changes (${headBranch})`
                });
                core.info(`Successfully auto-merged PR #${pr.number}`);
              } else if (prDetails.mergeable === false) {
                core.info(`PR #${pr.number} has conflicts - manual review required`);
              } else {
                core.info(`PR #${pr.number} mergeable status unknown - manual review recommended`);
              }
              
            } catch (e) {
              core.setFailed(`Failed to process PR: ${e.message}`);
            }
